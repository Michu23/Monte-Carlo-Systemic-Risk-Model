import { useState, useCallback } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { addNotification } from '../store/uiSlice';\n\n/**\n * Custom hook for handling async operations with loading states and error handling\n * @param {Object} options - Configuration options\n * @returns {Object} - Hook utilities\n */\nexport const useAsyncOperation = (options = {}) => {\n  const {\n    showSuccessNotification = false,\n    showErrorNotification = true,\n    successMessage = 'Operation completed successfully',\n    errorMessage = 'Operation failed',\n    onSuccess,\n    onError\n  } = options;\n\n  const dispatch = useDispatch();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n\n  const execute = useCallback(async (asyncFunction, ...args) => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const result = await asyncFunction(...args);\n      setData(result);\n      \n      if (showSuccessNotification) {\n        dispatch(addNotification({\n          type: 'success',\n          message: successMessage\n        }));\n      }\n      \n      if (onSuccess) {\n        onSuccess(result);\n      }\n      \n      return result;\n    } catch (err) {\n      const errorMsg = err.response?.data?.message || err.message || errorMessage;\n      setError(errorMsg);\n      \n      if (showErrorNotification) {\n        dispatch(addNotification({\n          type: 'error',\n          message: errorMsg\n        }));\n      }\n      \n      if (onError) {\n        onError(err);\n      }\n      \n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [dispatch, showSuccessNotification, showErrorNotification, successMessage, errorMessage, onSuccess, onError]);\n\n  const reset = useCallback(() => {\n    setLoading(false);\n    setError(null);\n    setData(null);\n  }, []);\n\n  return {\n    loading,\n    error,\n    data,\n    execute,\n    reset\n  };\n};\n\n/**\n * Hook for handling form submissions with validation and error handling\n * @param {Function} submitFunction - Function to call on form submit\n * @param {Object} options - Configuration options\n * @returns {Object} - Hook utilities\n */\nexport const useFormSubmission = (submitFunction, options = {}) => {\n  const {\n    validate,\n    showSuccessNotification = true,\n    successMessage = 'Form submitted successfully',\n    resetOnSuccess = false\n  } = options;\n\n  const [values, setValues] = useState({});\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  \n  const { loading, error, execute } = useAsyncOperation({\n    ...options,\n    showSuccessNotification,\n    successMessage\n  });\n\n  const handleChange = useCallback((name, value) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    // Clear field error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: null }));\n    }\n  }, [errors]);\n\n  const handleBlur = useCallback((name) => {\n    setTouched(prev => ({ ...prev, [name]: true }));\n    \n    // Validate field on blur if validation function is provided\n    if (validate) {\n      const fieldErrors = validate({ [name]: values[name] });\n      if (fieldErrors[name]) {\n        setErrors(prev => ({ ...prev, [name]: fieldErrors[name] }));\n      }\n    }\n  }, [validate, values]);\n\n  const handleSubmit = useCallback(async (e) => {\n    if (e) {\n      e.preventDefault();\n    }\n    \n    // Validate all fields\n    if (validate) {\n      const validationErrors = validate(values);\n      setErrors(validationErrors);\n      \n      if (Object.keys(validationErrors).length > 0) {\n        return;\n      }\n    }\n    \n    try {\n      const result = await execute(submitFunction, values);\n      \n      if (resetOnSuccess) {\n        setValues({});\n        setErrors({});\n        setTouched({});\n      }\n      \n      return result;\n    } catch (err) {\n      // Handle validation errors from server\n      if (err.response?.status === 422 && err.response?.data?.errors) {\n        setErrors(err.response.data.errors);\n      }\n      throw err;\n    }\n  }, [values, validate, execute, submitFunction, resetOnSuccess]);\n\n  const reset = useCallback(() => {\n    setValues({});\n    setErrors({});\n    setTouched({});\n  }, []);\n\n  return {\n    values,\n    errors,\n    touched,\n    loading,\n    error,\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    reset\n  };\n};\n\n/**\n * Hook for handling data fetching with loading states and error handling\n * @param {Function} fetchFunction - Function to fetch data\n * @param {Array} dependencies - Dependencies to trigger refetch\n * @param {Object} options - Configuration options\n * @returns {Object} - Hook utilities\n */\nexport const useDataFetching = (fetchFunction, dependencies = [], options = {}) => {\n  const {\n    immediate = true,\n    showErrorNotification = true,\n    errorMessage = 'Failed to fetch data'\n  } = options;\n\n  const { loading, error, data, execute } = useAsyncOperation({\n    showErrorNotification,\n    errorMessage\n  });\n\n  const [lastFetch, setLastFetch] = useState(null);\n\n  const fetch = useCallback(async (...args) => {\n    const result = await execute(fetchFunction, ...args);\n    setLastFetch(new Date());\n    return result;\n  }, [execute, fetchFunction]);\n\n  const refetch = useCallback(() => {\n    return fetch();\n  }, [fetch]);\n\n  // Auto-fetch on mount and dependency changes\n  React.useEffect(() => {\n    if (immediate) {\n      fetch();\n    }\n  }, dependencies);\n\n  return {\n    data,\n    loading,\n    error,\n    fetch,\n    refetch,\n    lastFetch\n  };\n};\n\n/**\n * Hook for handling retry logic with exponential backoff\n * @param {Function} operation - Operation to retry\n * @param {Object} options - Configuration options\n * @returns {Object} - Hook utilities\n */\nexport const useRetry = (operation, options = {}) => {\n  const {\n    maxAttempts = 3,\n    baseDelay = 1000,\n    maxDelay = 10000,\n    backoffFactor = 2\n  } = options;\n\n  const [attempts, setAttempts] = useState(0);\n  const [isRetrying, setIsRetrying] = useState(false);\n  \n  const { loading, error, execute } = useAsyncOperation(options);\n\n  const retry = useCallback(async (...args) => {\n    let currentAttempt = 0;\n    \n    while (currentAttempt < maxAttempts) {\n      try {\n        setAttempts(currentAttempt + 1);\n        \n        if (currentAttempt > 0) {\n          setIsRetrying(true);\n          const delay = Math.min(\n            baseDelay * Math.pow(backoffFactor, currentAttempt - 1),\n            maxDelay\n          );\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n        \n        const result = await execute(operation, ...args);\n        setIsRetrying(false);\n        return result;\n        \n      } catch (err) {\n        currentAttempt++;\n        \n        if (currentAttempt >= maxAttempts) {\n          setIsRetrying(false);\n          throw err;\n        }\n      }\n    }\n  }, [execute, operation, maxAttempts, baseDelay, maxDelay, backoffFactor]);\n\n  const reset = useCallback(() => {\n    setAttempts(0);\n    setIsRetrying(false);\n  }, []);\n\n  return {\n    loading,\n    error,\n    attempts,\n    isRetrying,\n    retry,\n    reset,\n    canRetry: attempts < maxAttempts\n  };\n};\n\nexport default useAsyncOperation;"